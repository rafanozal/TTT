param<-1:30
for(i in 1:length(param)){ll[i]<-log.lik(param[i])}
plot(param,ll)
ll<-double(length(param))
for(i in 1:length(param)){ll[i]<-log.lik(param[i])}
plot(param,ll)
log.lik<-function(param)
{
a<-param[1];
b<-param[2]
n<-length(datos)
f.datos<-double(n)
for(i in 1:n){f.datos[i]<-f(datos[i],a,b)}
return(-sum(log(f.datos)))
}
library(Rsolnp)
pars<-c(1,1)
res<-solnp(pars=pars,fun=log.lik,LB = c(0,0),control=list(trace=0))
param<-res$pars
param
res<-solnp(pars=pars,fun=log.lik)#,LB = c(0,0),control=list(trace=0))
simula.Wmod<-function(n,a,b,c) {
uu<-runif(n)
f.u<-function(t,u)
return(b*log(t)+c*t+log(a)-log(-log(1-u)))
t.u<-sapply(1:n,function(i)
{return(uniroot(f.u,c(0,1e+04),u=uu[i])$root)})
i0<-which(t.u==0)
t.u[i0]<-t.u[i0]+1e-4
t.u }
n <- 250
(t <- simula.Wmod(n,1,2,0.5))
f.likWmod<-function(x) {
a <- x[1]
b <- x[2]
c <- x[3]
log.lik1 <- n*log(a)+(b-1)*sum(log(t))+sum(log(b+c*t)) +c*sum(t)-a*sum(t^(b)*exp(c*t))
return(-log.lik1) }
grWmod <- function(x) {
a <- x[1]
b <- x[2]
c <- x[3]
gr1 <- sum((1/a)-t^(b)*exp(c*t))
gr2 <- sum(log(t)+1/(b+c*t)-a*t^(b)*exp(c*t)*log(t))
gr3 <- sum(t/(b+c*t)+t-a*t^(b+1)*exp(c*t))
return <- c(-gr1,-gr2,-gr3) }
(result1 <- optim(c(1.5,2.36,1), f.likWmod, grWmod, method = "BFGS"))
vari.M<-function(n)return(n^{-8/9}
vari.M<-function(n)return(n^{-8/9})
vari.LL<-function(n)return(n^{-4/5})
curve(vari.M(x),1,200,ylim=c(0,1))
curve(vari.LL(x),1,200,ylim=c(0,1),add=T,col=2)
28/45
4/9
23/49
29/62
11/46
15/53
20/107
v<-3
n<-4
n<-5
v1<-rep(1,5)
v2<-rep(0,5)
as.matrix(expand.grid(v1,v2))
sheet1<-rep(0,282)
sheet1<-matrix(0,282,4)
sheet1[1:94,1]<-1
sheet1[,3:4]<-1
sheet1
sheet2<-sheet1
sheet2[,3]<-0
sheet3<-sheet1
sheet3[,4]<-0
sheet4<-sheet1
sheet4[,3:4]<-0
sheet4
z.mat<-cbind(sheet1,sheet2,sheet3,sheet4)
nrow(z.mat)
z.mat<-rbind(sheet1,sheet2,sheet3,sheet4)
nrow(z.mat)
x<-1:94
x.mat<-matrix(1,1128,2)
x.mat[,2]<-rep(x,12)
x.mat
XZ.mat<-cbind(x.mat,z.mat)
head(XZ.mat)
KK.sextic<-function(t)
{
c<-(3003/2048)^2
t<-abs(t)
a<-t-1;b<-1
x<-seq(a,b,length=100)
Kx<-(1-x^2)^6;Ktx<-(1-(t-x)^2)^6
#  y<-sapply(1:100,function(i) return(((1-t^2)+2*t*x[i]-(t^2-2)*x[i]^2-2*t*x[i]^3+x[i]^4)^6))
y<-Kx*Ktx
#Trapezoidal rule integration
idx = 2:length(x)
res<-(as.double( (x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2)
res<-c*res
return(res)
}
K.epa<-function(u) return(0.75*(1-u^2)*(abs(u)<1)) #epa
K.sextic<-function(u) { return(((3003/2048)*(1-u^2)^6*(abs(u)<1))) }
#convolution
K.K<-function(u,ker)
{
if (ker=='epa') {K<-K.epa}
if (ker=='sextic') {K<-K.sextic}
KK.u<-function(u)
{
KK<-function(s){return(K(s)*K(u-s))}
linf<-max(-1,-1+u);lsup<-min(1,1+u)
res<-integrate(KK,linf,lsup)$value
return(res*(abs(u)<2))
}
return(sapply(u,KK.u))
}
KK.s<-function(x)return(K.K(x,'sextic'))
t<-0.5
KK.s(t)
KK.sextic(0.5)
t
t<-abs(t)
a<-t-1;b<-1
x<-seq(a,b,length=100)
Kx<-(1-x^2)^6;Ktx<-(1-(t-x)^2)^6
#  y<-((1-t^2)+2*t*x+(t^2-2)*x^2-2*t*x^3+x^4)^6)
y<-Kx*Ktx
y1<-((1-t^2)+2*t*x+(t^2-2)*x^2-2*t*x^3+x^4)^6)
y1<-((1-t^2)+2*t*x+(t^2-2)*x^2-2*t*x^3+x^4)^6
y
y1
KK.sextic<-function(t)
{
c<-(3003/2048)^2
t<-abs(t)
a<-t-1;b<-1
x<-seq(a,b,length=100)
#Kx<-(1-x^2)^6;Ktx<-(1-(t-x)^2)^6
y<-sapply(t,((1-t^2)+2*t*x+(t^2-2)*x^2-2*t*x^3+x^4)^6)
#y<-Kx*Ktx
#Trapezoidal rule integration
idx = 2:length(x)
res<-((x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2
res<-c*res
return(res)
}
KK.sextic(0.5)
KK.sextic<-function(t)
{
c<-(3003/2048)^2
t<-abs(t)
a<-t-1;b<-1
x<-seq(a,b,length=100)
#Kx<-(1-x^2)^6;Ktx<-(1-(t-x)^2)^6
y<-sapply(t,function(ti)return((1-ti^2)+2*ti*x+(ti^2-2)*x^2-2*ti*x^3+x^4)^6)
#y<-Kx*Ktx
#Trapezoidal rule integration
idx = 2:length(x)
res<-((x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2
res<-c*res
return(res)
}
KK.sextic(0.5)
c<-(3003/2048)^2
t<-abs(t)
a<-t-1;b<-1
x<-seq(a,b,length=10)
#Kx<-(1-x^2)^6;Ktx<-(1-(t-x)^2)^6
y<-sapply(t,function(ti)return((1-ti^2)+2*ti*x+(ti^2-2)*x^2-2*ti*x^3+x^4)^6)
x
t
y
ti<-t[1]
(1-ti^2)+2*ti*x+(ti^2-2)*x^2-2*ti*x^3+x^4)^6
KK.sextic<-function(t)
{
c<-(3003/2048)^2
t<-abs(t)
a<-t-1;b<-1
x<-seq(a,b,length=10)
#Kx<-(1-x^2)^6;Ktx<-(1-(t-x)^2)^6
y<-sapply(t,function(ti)return(((1-ti^2)+2*ti*x+(ti^2-2)*x^2-2*ti*x^3+x^4)^6))
#y<-Kx*Ktx
#Trapezoidal rule integration
idx = 2:length(x)
res<-((x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2
res<-c*res
return(res)
}
KK.sextic(0.5)
curve(KK.sextic)
KK.sextic<-function(t)
{
c<-(3003/2048)^2
t<-abs(t)
a<-t-1;b<-1
x<-seq(a,b,length=10)
#Kx<-(1-x^2)^6;Ktx<-(1-(t-x)^2)^6
y<-sapply(1:length(t),function(i)return(((1-t[i]^2)+2*t[i]*x+(ti^2-2)*x^2-2*t[i]*x^3+x^4)^6))
#y<-Kx*Ktx
#Trapezoidal rule integration
idx = 2:length(x)
res<-((x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2
res<-c*res
return(res)
}
curve(KK.sextic)
KK.sextic<-function(t)
{
c<-(3003/2048)^2
KK.i<-function(ti)
{
ti<-abs(ti)
a<-ti-1;b<-1
x<-seq(a,b,length=10)
Kx<-(1-x^2)^6;Ktx<-(1-(ti-x)^2)^6
y<-Kx*Ktx
#Trapezoidal rule integration
idx = 2:length(x)
res<-((x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2
res<-c*res
return(res)
}
res<-sapply(t,KK.i)
}
KK.sextic(0.5)
KK.sextic<-function(t)
{
c<-(3003/2048)^2
KK.i<-function(ti)
{
ti<-abs(ti)
a<-ti-1;b<-1
x<-seq(a,b,length=10)
Kx<-(1-x^2)^6;Ktx<-(1-(ti-x)^2)^6
y<-Kx*Ktx
#Trapezoidal rule integration
idx = 2:length(x)
res<-((x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2
res<-c*res
return(res)
}
res<-sapply(t,KK.i)
return(res)
}
KK.sextic(0.5)
KK.sextic(c(0.5,1))
curve(KK.sextic)
curve(KK.sextic(x),-2,2)
KK.sextic<-function(t,ker)
{
KK.i<-function(ti)
{
ti<-abs(ti)
a<-ti-1;b<-1
x<-seq(a,b,length=10)
if (ker='epa'){c<-0.75^2; Kx<-(1-x)^2;Ktx<-(1-(ti-x)^2)}
if(ker=='sextic'){c<-(3003/2048)^2;  Kx<-(1-x^2)^6;Ktx<-(1-(ti-x)^2)^6}
y<-Kx*Ktx
#Trapezoidal rule integration
idx = 2:length(x)
res<-((x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2
res<-c*res
return(res)
}
res<-sapply(t,KK.i)
return(res)
}
KK.sextic<-function(t,ker)
{
KK.i<-function(ti)
{
ti<-abs(ti)
a<-ti-1;b<-1
x<-seq(a,b,length=10)
if (ker=='epa'){c<-0.75^2; Kx<-(1-x)^2;Ktx<-(1-(ti-x)^2)}
if(ker=='sextic'){c<-(3003/2048)^2;  Kx<-(1-x^2)^6;Ktx<-(1-(ti-x)^2)^6}
y<-Kx*Ktx
#Trapezoidal rule integration
idx = 2:length(x)
res<-((x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2
res<-c*res
return(res)
}
res<-sapply(t,KK.i)
return(res)
}
K.K<-function(t,ker)
{
KK.i<-function(ti)
{
ti<-abs(ti)
a<-ti-1;b<-1
x<-seq(a,b,length=10)
if (ker=='epa'){c<-0.75^2; Kx<-(1-x)^2;Ktx<-(1-(ti-x)^2)}
if(ker=='sextic'){c<-(3003/2048)^2;  Kx<-(1-x^2)^6;Ktx<-(1-(ti-x)^2)^6}
y<-Kx*Ktx
#Trapezoidal rule integration
idx = 2:length(x)
res<-((x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2
res<-c*res
return(res)
}
res<-sapply(t,KK.i)
return(res)
}
40/136
21/63
R_serie_id<-function(n,p)
{
#n= tamaqo del sistema
#p= fiabildad de una componente
R.s<-p^n
return(R.s)
}
N<-2:10
P<-seq(0,1,length=10)
R<-outer(N,P,R_serie_id )
x11();persp(N,P,R,theta=60,col='blue')
p<-seq(0.1,0.9,length=5) ####fiabilidad de una componente entre 0.1 y 0.9 (5 casos)
nn<-2:100 ####sistemas con componentes entre 2 y 100
R<-matrix(0,length(nn),length(p))
for(i in 1:length(p))
{
for(j in 1:length(nn)){
R[j,i]<-R_serie_id(nn[j],p=p[i])}
}
#pi<-c(0.1,0.3,0.5,0.7,0.9)
x11(); plot(nn,R[,1],ylim=range(R),type='l',xlab='Num.comp.',ylab='Fiab.')
for(i in 1:5){lines(nn,R[,i],col=i)}
#Distribucisn normal.
n <- 100
a <- 50
b <- 5
x <- round(rnorm(n,a,b),2)
#Apartadoa. Funcisn fiabilidad empmrica.
ti <- sort(x)
n <- length(ti)
pi <- ((1:n)-3/8)/(n+1/4)
yi <- qnorm(pi, 0, 1)
xi <- log(ti)
fit.ln<-lm(yi~xi)
coeficientes<-fit.ln$coefficients
slope<-coeficientes[2]
intercept<-coeficientes[1]
estim.param.ln<-matrix(c(-intercept/slope,1/slope),1,2)
colnames(estim.param.ln)<-c('mu','sigma')
estim.param.ln  #debes ser parecidos a "a" y "b" respectivamente
estim.mu<-estim.param.ln[1];estim.sigma<-estim.param.ln[2]
plot(ti,1-pi,ylab = 'S(t)',xlab = 't', main = 'Funcisn de fiabilidad empmrica',type = 's',ylim = c(0,1))
lines(ti,1-pnorm(log(ti),mean=estim.mu,sd=estim.sigma),col=4,lwd=2)
#Apartadob. Grafico de probabilidad normal de la muestra.
qqnorm(xi,main = "Grafica de probabilidad normal",ylab="xi" ,xlab="Cuantiles Tesricos",lwd=2,col=2,pch=16)
qqline(xi,col=4)
x <- read.table("tfallo.txt")
x <- as.matrix(x)
x
#Apartadoa. Modelo Weibull.
ti<-sort(x)
n<-length(ti)
pi<-(1:n)/(n+1) #dividimos por n+1 en lugar de n para evitar problemas en el ultimo dato
#obtenemos las coordenadas del grafico q-q
xi<-log(ti)
yi<-log(-log(1-pi))
#ajustamos la recta
fit.w<-lm(yi~xi)
#coeficientes de la recta
coeficientes<-fit.w$coefficients
resumen.w <- summary(fit.w)
R2w <- round(resumen.w$adj.r.squared,4)
slope<-coeficientes[2]
intercept<-coeficientes[1]
#Parametros weibull
estim.param.w<-matrix(c(1/slope,exp(-intercept)),1,2)
colnames(estim.param.w)<-c('Parametro de forma','Parametro de escala')
estim.param.w
#curva estimada
plot(xi,yi,main='Grafico q-q Weibull', ylab='',xlab='')
lines(xi,intercept+slope*xi,lty=1,col=3,lwd=2)
legend('bottomright',legend=c("R^2 ajustado",R2w),bty='n')
#Apartadob. Modelo exponencial.
pi<-(0.5:n-0.5)/(n)
xi<-ti
yi<-(-log(1-pi))
fit.e<-lm(yi~xi)
resumen.e<-summary(fit.e)
coeficientes.e<-fit.e$coefficients
R2e<-round(resumen.e$adj.r.squared,4)
slope<-coeficientes.e[2]
intercept<-coeficientes.e[1]
lambda<-as.numeric(slope)
localizacion.e<- intercept
names(lambda)<-"Parametro lambda"
lambda
names(localizacion.e)<-"Parametro de localizacisn"
localizacion.e
plot(xi,yi,main = 'Grafica q-q Exponencial',ylab = '',xlab = '')
lines(xi,intercept + slope*xi,col=2,lwd=2)
legend('bottomright', legend = c("R^2 ajustado ",R2e),bty='n')
#Apartadod. Ajuste de la media y la mediana para la distribucisn exponencial.
Mediana<-(log(2))/lambda
Media<-1/lambda
names(Mediana) <- "Mediana"
names(Media) <- "Media"
Mediana
Media
#Weibull
beta <- 2.75
alfa <- 5.01
a <- 1/beta #Parametro de forma
b <- exp(-alfa) #Parametro de escala
a
b
#Simulo la muestra
beta <- 2.75
alfa <- 5.01
datos <- round(rweibull(n,beta,alfa),2)
Media <- mean(datos)
Media
Mediana <- median(datos)
Mediana
datos <- c(94.9,106.9,229.7,275.7,144.5,112.8,159.3,153.1,270.6,322.0,216.4,544.6,266.2,263.6,138.5,79.0,114.6,66.1,131.2,91.1)
datos
#Grafico probabilidad lognormal y estimacisn de media y desviacisn tmpica
#Media y desviacisn tmpica
ti<-sort(datos)
n<-length(ti)
pi<- ((1:n)-3/8)/(n+1/4)
yi<-qnorm(pi,0,1)
xi<-log(ti)
fit.ln<-lm(yi~xi)
#coeficientes de la recta
coeficientes<-fit.ln$coefficients
resumen.ln<-summary(fit.ln)
R2ln<-round(resumen.ln$adj.r.squared,4)
slope<-coeficientes[2]
intercept<-coeficientes[1]
estim.param.ln<-matrix(c(-intercept/slope,1/slope),1,2)
colnames(estim.param.ln)<-c('mu','sigma')
estim.param.ln
estim.mu<-estim.param.ln[1]
estim.sigma<-estim.param.ln[2]
plot(xi,yi,ylab='',xlab='',main='Grafico q-q LogNormal')
lines(xi,intercept + slope*xi,lty=1,col=4,lwd=2)
legend('bottomright', legend = c('R^2 ajustada ',R2ln),bty='n')
#Tabla de vida
I<-c(0,10,25,75,100,500,750,1000,1500,2000,2500,3000,3600,3700,3800,Inf)
d<-c(0,0,0,0,0,0,0,0,0,0,1,1,3,1,0,0)
w<-c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22)
n<-28
k<-length(I)
ni<-double(k)
ni[1]<-n
for(i in 2:k){ni[i]<-n-d[i-1]-w[i-1]}
ni_star<-double(k)
for(i in 1:k){ni_star[i]<-ni[i]-w[i]/2}
q<-double(k)
for(i in 1:k){q[i]<-d[i]/ni_star[i]}
R<-double(k)
R[1]<-1
for(i in 2:k){R[i]<-R[i-1]*(1-q[i])}
tabladevida<-data.frame(Ii=I,di=d,wi=w,ni=ni,ni_star=ni_star,qi=q,Ri=R)
tabladevida
plot(I,R,type='s',lwd=2,main="Funcisn de fiabilidad estimada",xlab="I_i",ylab="R(i)",ylim=c(0,1),col=2)
#Apartadob. Error estandar del estimador.
error<-double(k)
for(i in 1:k){error[i]<-sqrt(R[i]^2*cumsum(d/(ni_star*(ni_star-d)))[i])
}
tabla<-cbind(tabla,error=error)
library(haven)
Datos_para_test_COVID <- read_sav("D:/Desktop/Datos para test COVID.sav")
View(Datos_para_test_COVID)
table(Datos_para_test_COVID$TestRápido)
write.table(Datos_para_test_COVID,'test_covid.txt')
setwd("C:/Users/Usuario/Dropbox/TTT/MOSFET/R/out")
# Add the needed libraries
# -----------------------------------------------------------------------------
library(reshape2) # melt
source("toolsBasic.R",    encoding="utf-8")
setwd("C:/Users/Usuario/Dropbox/TTT/MOSFET/R/src")
# Add the needed libraries
# -----------------------------------------------------------------------------
library(reshape2) # melt
source("toolsBasic.R",    encoding="utf-8")
install.packages("ggnewscale")
source("toolsBasic.R",    encoding="utf-8")
setwd("C:/Users/User/Dropbox/TTT/MOSFET/R/data")
datos_backfit <- read.csv("C:/Users/User/Dropbox/TTT/MOSFET/R/data/datos_backfit.txt", sep="")
View(datos_backfit)
plot(datos_backfit$Vth)
plot(scale(datos_backfit$Vth))
scale(datos_backfit$Vth)
summary(datos_backfit$Vth)
range(scale(datos_backfit$Vth))
diff(range(scale(datos_backfit$Vth)))
vth<-datos_backfit$Vth
plot(vth/max(vth))
diff(range(vth))
x<-(vth-min(vth))/(max(vth)-min(vth))
plot(x)
curve(cos(x),0,10)
m<-function(x){cos(x*2*pi)}
curve(m)
m<-function(x){(cos(x*2*pi)+1)/2}
curve(m)
m<-function(x){(cos(x*2*pi)+1)/10}
curve(m,add=T,col=2)
m<-function(x){(cos(x*3*pi)+1)/10}
curve(m,add=T,col=4)
curve(m,col=4)
