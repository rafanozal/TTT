A
max.min(A)
n1<-nrow(A);n2<-ncol(A)
col.max<-double(n2);for(i in 1:n2){col.max[i]<-max(A[,i])}
col.max
A<-matrix(round(runif(9,0,1),3),3,3)
max.min(A)
A
A<-matrix(round(runif(9,0,1),3),3,3)
A
max.min(A)
A<-matrix(round(runif(9,0,1),3),3,3)
max.min(A)
A<-matrix(round(runif(9,0,1),3),3,3)
max.min(A)
A<-matrix(round(runif(9,0,1),3),3,3)
A
max.min(A)
redun.activa<-function(A)
{
n1<-nrow(A);n2<-ncol(A)
col.max<-double(n2);for(i in 1:n2){col.max[i]<-max(A[,i])}
fila.min<-double(n1);for(i in 1:n1){fila.min[i]<-min(A[i,])}
resultados<-list(serie.par.A=min(col.max),par.serie.A=max(fila.min))
return(resultados)
}
redun.pasiva<-function(A)
{
n1<-nrow(A);n2<-ncol(A)
col.max<-double(n2);for(i in 1:n2){col.max[i]<-sum(A[,i])}
fila.min<-double(n1);for(i in 1:n1){fila.min[i]<-min(A[i,])}
resultados<-list(serie.par.A=min(col.max),par.serie.A=sum(fila.min))
return(resultados)
}
A<-matrix(round(runif(9,0,1),3),3,3)
A
redun.activa(A)
redun.pasiva(A)
A
A<-matrix(round(runif(9,0,1),3),3,3)
redun.pasiva(A)
redun.activa(A)
library(DOvalidation)
b.OSCV
model<-5
if (model==5){delta.M<-70/(M-1);t.grid<-seq(40,110,by=delta.M)}else{
t.grid<-seq(1/101,100/101,length.out=M)}#;delta.M<-1/M }
delta.M<-t.grid[2]-t.grid[1]
M<-500
if (model==5){delta.M<-70/(M-1);t.grid<-seq(40,110,by=delta.M)}else{
t.grid<-seq(1/101,100/101,length.out=M)}#;delta.M<-1/M }
delta.M<-t.grid[2]-t.grid[1]
delta.M
rm(list=ls())
library(DOvalidation)
alpha.IS<-function(x) #parametric model
{
#country='IS'
a0<--10.1136;a1<-.05708;a2<-.0003689; sigma<-0.005556^0.5 #Spreeuw et al. (2012)
#a0<--10.09691;a1<-0.05912031;a2<-0.0003586944; sigma<-0.04538511 #los nuestros
mu.bar<-function(x) return(exp(a0+a1*x+a2*x^2))
M.bar<-function(x) {sapply(1:length(x),function(i)integrate(mu.bar,lower=0,upper=x[i])$value)}
return( mu.bar(x)*(1+sigma^2*M.bar(x))^(-1))
}
simula.sample.iid<-function(ss,model,t.grid,delta.M,N,M)#,trun=0,pc=0)
{
if (model==1) alpha<-function(t)  dbeta(t,2,2)
if (model==2) alpha<-function(t)  dbeta(t,4,4)
if (model==3) alpha<-function(t)  0.6*(dbeta(t,0.5,0.5)+dbeta(t,7,7))
if (model==4) alpha<-function(t)  0.6*(dbeta(t,0.5,0.5)+dbeta(t,4,2)+dbeta(t,2,4))
if (model==5) alpha<-function(t)  alpha.IS(t)
# ss is the replication number to repeate always the same sequence
# gt.model is a unidimensional function to calculate the true bidimensional hazard for each model=1,2,3,4
# N is the sample size
# t.grid is a equaly spaced grid of M time points
## if (model==5){t.grid<-seq(40.1,109,length.out=M)}else{t.grid<-seq(1/101,100/101,length.out=M)  }
# 1. Define three vectors:
# - P.t the failure probabilities
# - O.t the ocurrences
# - E.t exposures
# Define a vector P.t to store the probabilities for the binomial at each point in the grid
ss<-ss+1;set.seed(ss)
#T.t<-double(M);tc<-0
P.t<-double(M)
P.t<-alpha(t.grid)*delta.M #/(M+1)
P.t[P.t>1]<-1
O.t<-E.t<-C.t<-double(M)
E.t[1]<-as.integer(N) #-tc
X<-double(M)
for (i in 1:M)
{
if (E.t[i]>0 ) O.t[i]<-rbinom(1,size=E.t[i],prob=P.t[i]) else O.t[i]<-0
X[i]<-E.t[i]-O.t[i]
#C.t[i]<-rbinom(1,size=X[i],prob=pc)  # =0 for iid
if (i<M)
{
E.t[i+1]<-E.t[i]-O.t[i]
# E.t[i+1]<-E.t[i]-(O.t[i]+C.t[i])+T.t[i] #replaces the next period exposures with last period exposures minus last period occurrences
}
}
E.t<-E.t*delta.M
#it returns two vectors with occurrences and exposures
return(list(xi=t.grid,Oi=c(O.t),Ei=c(E.t)))#,C.t=C.t,T.t=T.t))
}
ISE.b<-function(b,model,N,xi,Oi,Ei,K)
{
if (model==1) alpha<-function(t)  dbeta(t,2,2)
if (model==2) alpha<-function(t)  dbeta(t,4,4)
if (model==3) alpha<-function(t) 0.6*(dbeta(t,0.5,0.5)+dbeta(t,7,7))
if (model==4) alpha<-function(t) 0.6*(dbeta(t,0.5,0.5)+dbeta(t,4,2)+dbeta(t,2,4))
if (model==5) alpha<-function(t)  alpha.IS(t)
alpha.xi<-alpha(xi)
alpha.estim<-hazard.LL(xi=xi,Oi=Oi,Ei=Ei,x=xi,b=b,K="sextic",Ktype="symmetric",CI=FALSE)$hLL
delta.M<-xi[2]-xi[1]
# if (model==5){deltai=diff(c(39,xi))}else{deltai=diff(c(0,xi))}
dif.b<-as.vector((alpha.estim-alpha.xi)^2 *delta.M)  ####CAMBIO ISE!!!
Q0<-sum(dif.b,na.rm=T)/N; Q0[Q0==0]<-NA
return(Q0)
}
b.ISE<-function(grid.b,model,N,xi,Oi,Ei,K)
{ ### The weight function is taken as wi=1 or wi=deltai/Ei
M <- length(xi)
delta.M <- xi[2] - xi[1]
if (missing(grid.b)) {
amp <- xi[M] - xi[1]
b.min <- amp/(M + 1)
b.max <- amp/2
if (missing(nb))
nb <- 50
grid.b <- seq(b.min, b.max, length = nb)
}
nb <- length(grid.b)
ise.values<-sapply(grid.b, function(b){return(ISE.b(b,model=model,N=N,xi=xi,Oi=Oi,Ei=Ei,K=K))})
ind.ise<-which.min(ise.values)
bISE<-grid.b[ind.ise]
ISE.res<-list(bISE=bISE,ind.ise=ind.ise,ise.values=ise.values,grid.b=grid.b)
return(ISE.res$bISE)
}
model<-5
N<-50000
M<-500
K<-'sextic'
fil.res<-paste("DO_validation_model",model,"_M",M,"_N",N,".txt",sep="")
fil.res
if (model==5){delta.M<-70/(M-1);t.grid<-seq(40,110,by=delta.M)}else{
t.grid<-seq(1/101,100/101,length.out=M)}#;delta.M<-1/M }
delta.M<-t.grid[2]-t.grid[1]
i<-1
datos<-simula.sample.iid(ss=i,model,t.grid,delta.M,N,M)
xi<-datos$xi
Oi<-datos$Oi
Ei<-datos$Ei
if (model==1) alpha<-function(t)  dbeta(t,2,2)
if (model==2) alpha<-function(t)  dbeta(t,4,4)
if (model==3) alpha<-function(t) 0.6*(dbeta(t,0.5,0.5)+dbeta(t,7,7))
if (model==4) alpha<-function(t) 0.6*(dbeta(t,0.5,0.5)+dbeta(t,4,2)+dbeta(t,2,4))
if (model==5) alpha<-function(t)  alpha.IS(t)
hi.teo<-alpha(xi)
M <- length(xi)
delta.M <- xi[2] - xi[1]
amp <- xi[M] - xi[1]
b.min <- amp/(M + 1)
b.max <- amp/2
if (missing(nb))
nb <- 50
amp <- xi[M] - xi[1]
b.min <- amp/(M + 1)
b.max <- amp/2
grid.b <- seq(b.min, b.max, length = nb)
M<-500;nb<-50
grid.b <- seq(b.min, b.max, length = nb)
nb <- length(grid.b)
bleft<-b.OSCV(grid.b=grid.b,nb=nb,K="sextic",Ktype="left",xi=xi,Oi=Oi,Ei=Ei,wei='same')$boscv
bright<-b.OSCV(grid.b=grid.b,nb=nb,K="sextic",Ktype="right",xi=xi,Oi=Oi,Ei=Ei,wei='same')$boscv
bDO<-(bleft+bright)/2
ISE.DO<-ISE.b(b=bDO,model=model,N=N,xi=xi,Oi=Oi,Ei=Ei,K='sextic')
b.optim<-b.ISE(grid.b,model,N,xi=xi,Oi=Oi,Ei=Ei,K='sextic')
ISE.Optim<-ISE.b(b=b.optim,model=model,N=N,xi=xi,Oi=Oi,Ei=Ei,K='sextic')
resu1<-c(i,b.optim,bDO)
resu2<-c(ISE.Optim,ISE.DO);
resu<-c(resu1,resu2)
nnames<-c('i','b.Optim','b.DO','ISE.Optim','ISE.DO')
names(resu)<-nnames
resultados<-c(resu1,resu2*10^6)
names(resultados)<-nnames
print(resultados)
rm(list=ls())
library(DOvalidation)
alpha.IS<-function(x) #parametric model
{
#country='IS'
a0<--10.1136;a1<-.05708;a2<-.0003689; sigma<-0.005556^0.5 #Spreeuw et al. (2012)
#a0<--10.09691;a1<-0.05912031;a2<-0.0003586944; sigma<-0.04538511 #los nuestros
mu.bar<-function(x) return(exp(a0+a1*x+a2*x^2))
M.bar<-function(x) {sapply(1:length(x),function(i)integrate(mu.bar,lower=0,upper=x[i])$value)}
return( mu.bar(x)*(1+sigma^2*M.bar(x))^(-1))
}
simula.sample.iid<-function(ss,model,t.grid,delta.M,N,M)#,trun=0,pc=0)
{
if (model==1) alpha<-function(t)  dbeta(t,2,2)
if (model==2) alpha<-function(t)  dbeta(t,4,4)
if (model==3) alpha<-function(t)  0.6*(dbeta(t,0.5,0.5)+dbeta(t,7,7))
if (model==4) alpha<-function(t)  0.6*(dbeta(t,0.5,0.5)+dbeta(t,4,2)+dbeta(t,2,4))
if (model==5) alpha<-function(t)  alpha.IS(t)
# ss is the replication number to repeate always the same sequence
# gt.model is a unidimensional function to calculate the true bidimensional hazard for each model=1,2,3,4
# N is the sample size
# t.grid is a equaly spaced grid of M time points
## if (model==5){t.grid<-seq(40.1,109,length.out=M)}else{t.grid<-seq(1/101,100/101,length.out=M)  }
# 1. Define three vectors:
# - P.t the failure probabilities
# - O.t the ocurrences
# - E.t exposures
# Define a vector P.t to store the probabilities for the binomial at each point in the grid
ss<-ss+1;set.seed(ss)
#T.t<-double(M);tc<-0
P.t<-double(M)
P.t<-alpha(t.grid)*delta.M #/(M+1)
P.t[P.t>1]<-1
O.t<-E.t<-C.t<-double(M)
E.t[1]<-as.integer(N) #-tc
X<-double(M)
for (i in 1:M)
{
if (E.t[i]>0 ) O.t[i]<-rbinom(1,size=E.t[i],prob=P.t[i]) else O.t[i]<-0
X[i]<-E.t[i]-O.t[i]
#C.t[i]<-rbinom(1,size=X[i],prob=pc)  # =0 for iid
if (i<M)
{
E.t[i+1]<-E.t[i]-O.t[i]
# E.t[i+1]<-E.t[i]-(O.t[i]+C.t[i])+T.t[i] #replaces the next period exposures with last period exposures minus last period occurrences
}
}
E.t<-E.t*delta.M
#it returns two vectors with occurrences and exposures
return(list(xi=t.grid,Oi=c(O.t),Ei=c(E.t)))#,C.t=C.t,T.t=T.t))
}
ISE.b<-function(b,model,N,xi,Oi,Ei,K)
{
if (model==1) alpha<-function(t)  dbeta(t,2,2)
if (model==2) alpha<-function(t)  dbeta(t,4,4)
if (model==3) alpha<-function(t) 0.6*(dbeta(t,0.5,0.5)+dbeta(t,7,7))
if (model==4) alpha<-function(t) 0.6*(dbeta(t,0.5,0.5)+dbeta(t,4,2)+dbeta(t,2,4))
if (model==5) alpha<-function(t)  alpha.IS(t)
alpha.xi<-alpha(xi)
alpha.estim<-hazard.LL(xi=xi,Oi=Oi,Ei=Ei,x=xi,b=b,K="sextic",Ktype="symmetric",CI=FALSE)$hLL
delta.M<-xi[2]-xi[1]
# if (model==5){deltai=diff(c(39,xi))}else{deltai=diff(c(0,xi))}
dif.b<-as.vector((alpha.estim-alpha.xi)^2 *delta.M)  ####CAMBIO ISE!!!
Q0<-sum(dif.b,na.rm=T)/N; Q0[Q0==0]<-NA
return(Q0)
}
b.ISE<-function(grid.b,model,N,xi,Oi,Ei,K)
{ ### The weight function is taken as wi=1 or wi=deltai/Ei
M <- length(xi)
delta.M <- xi[2] - xi[1]
if (missing(grid.b)) {
amp <- xi[M] - xi[1]
b.min <- amp/(M + 1)
b.max <- amp/2
if (missing(nb))
nb <- 50
grid.b <- seq(b.min, b.max, length = nb)
}
nb <- length(grid.b)
ise.values<-sapply(grid.b, function(b){return(ISE.b(b,model=model,N=N,xi=xi,Oi=Oi,Ei=Ei,K=K))})
ind.ise<-which.min(ise.values)
bISE<-grid.b[ind.ise]
ISE.res<-list(bISE=bISE,ind.ise=ind.ise,ise.values=ise.values,grid.b=grid.b)
return(ISE.res$bISE)
}
model<-5
N<-50000
M<-500;nb<-50
K<-'sextic'
fil.res<-paste("DO_validation_model",model,"_M",M,"_N",N,".txt",sep="")
if (model==5){delta.M<-70/(M-1);t.grid<-seq(40,110,by=delta.M)}else{
t.grid<-seq(1/101,100/101,length.out=M)}#;delta.M<-1/M }
delta.M<-t.grid[2]-t.grid[1]
ini<-1;fin<-500
for(i in ini:fin)
{
datos<-simula.sample.iid(ss=i,model,t.grid,delta.M,N,M)
xi<-datos$xi
Oi<-datos$Oi
Ei<-datos$Ei
##0. TRUE HAZARDS
#### models
if (model==1) alpha<-function(t)  dbeta(t,2,2)
if (model==2) alpha<-function(t)  dbeta(t,4,4)
if (model==3) alpha<-function(t) 0.6*(dbeta(t,0.5,0.5)+dbeta(t,7,7))
if (model==4) alpha<-function(t) 0.6*(dbeta(t,0.5,0.5)+dbeta(t,4,2)+dbeta(t,2,4))
if (model==5) alpha<-function(t)  alpha.IS(t)
hi.teo<-alpha(xi)
### 3. Third estimator Do-validation
M <- length(xi)
delta.M <- xi[2] - xi[1]
amp <- xi[M] - xi[1]
b.min <- amp/(M + 1)
b.max <- amp/2
grid.b <- seq(b.min, b.max, length = nb)
nb <- length(grid.b)
bleft<-b.OSCV(grid.b=grid.b,nb=nb,K="sextic",Ktype="left",xi=xi,Oi=Oi,Ei=Ei,wei='same')$boscv
bright<-b.OSCV(grid.b=grid.b,nb=nb,K="sextic",Ktype="right",xi=xi,Oi=Oi,Ei=Ei,wei='same')$boscv
bDO<-(bleft+bright)/2
ISE.DO<-ISE.b(b=bDO,model=model,N=N,xi=xi,Oi=Oi,Ei=Ei,K='sextic')
### 4. Optimal b.ise
b.optim<-b.ISE(grid.b,model,N,xi=xi,Oi=Oi,Ei=Ei,K='sextic')
ISE.Optim<-ISE.b(b=b.optim,model=model,N=N,xi=xi,Oi=Oi,Ei=Ei,K='sextic')
# #Si.km<-exp(-cumsum((Oi/Ei)*deltai))
# ise.empi<-sum((hi.teo-Oi/Ei)^2*deltai,na.rm=T)/N ## the error with the Nelson-Aalen estimate
#
##results
resu1<-c(i,b.optim,bDO)
resu2<-c(ISE.Optim,ISE.DO);
resu<-c(resu1,resu2)
nnames<-c('i','b.Optim','b.DO','ISE.Optim','ISE.DO')
# names(resu)<-nnames
#  resultados<-c(resu1,resu2*10^6)
#  names(resultados)<-nnames
# print(resultados)
if (i==1){write(nnames,file=fil.res,append=F,ncol=length(resu))}
write(resu,file=fil.res,append=T,ncol=length(resu))
}
library(DOvalidation)
K.epa()
K.epa
e^(-0.000004)
exp(-0.000004)
exp(-0.000004*1e5)
install.packages("spreda")
install.packages("SPREDA")
library(survival)
library(SPREDA)
library(nmle)
install.packages("nlme")
library(survival)
library(SPREDA)
library(nlme)
fit <- survfit(Surv(time, status) ~ x, data = aml)
kaplan.meier.location(fit)
aml
fit <- survfit(Surv(time, status) ~ x, data = aml)
kk<-kaplan.meier.location(fit)
str(kk)
plot(kk)
datos<-sort(rweibull(100,2,2))
cens<-sample(c(0,1),size=100,replace=T,prob=c(0.2,0.8))
fit1<-survreg(Surv(datos,cens)~1,dist='weibull')
fit2=Lifedata.MLE(Surv(datos,cens)~1,  dist="weibull")
fit1
fit2
Lifedata.MLE
lifetime.mle
minus.log.lik.nlme
library(SPREDA)
library(boot)
library(lattice)
source("https://raw.githubusercontent.com/CodeOwl94/ross-reliability/master/ReliabilitySupportFns.R")
exa1 <- read.csv("https://raw.githubusercontent.com/CodeOwl94/ross-reliability/master/EXA1.csv",
header=T)
str(exa1)
dim(exa1)
head(exa1) # returns the first 6 rows:
stack(table(exa1$fail))
exa1$fail <- ifelse(exa1$fail=="S","T",as.character(exa1$fail))
exa1.dat <- data.frame(time=exa1$time,
event=1-as.numeric(as.logical(exa1$fail)))
stack(table(exa1.dat$event))
str(exa1.dat)
head(exa1.dat)
Plot.Observations(exa1.dat)
title("Figure 1", adj=1)
Plot.Observations(exa1.dat[order(exa1.dat$time),][1:60,])
?Plot.Observations
help(Plot.Observations)
ls()
Plot.Observations
rm(list=ls())
ls
ls()
source("https://raw.githubusercontent.com/CodeOwl94/ross-reliability/master/ReliabilitySupportFns.R")
ls()
add95CIs.Exponential
?unname
hazard.plot.w2p
library(SPREDA)
library(boot)
library(lattice)
source("https://raw.githubusercontent.com/CodeOwl94/ross-reliability/master/ReliabilitySupportFns.R")
exa1 <- read.csv("https://raw.githubusercontent.com/CodeOwl94/ross-reliability/master/EXA1.csv",
header=T)
####
ls()
help(dweibull)
ti<-c(7.74, 17.05,20.46, 21.02,22.66, 43.40, 47.30)
sum(ti)
8/45
1/9
4/9
28/45
1/9-1/5
c<-1/9-1/5
10^c
100^c
1000^c
10^-1/5
10^-1/9
10^-(1/9)
10^-(1/5)
10^{-1/5}
10^{-1/9}
10^{-1/5+1/9}
bias
biasa<-function(n,a)return(n^(-a))
vara<-function(n,b)return(n<-(-b))
bias1<-function(n)return(biasa(n,a=2/5))
bias2<-function(n)return(biasa(n,a=4/9))
bias3<-function(n)return(biasa(n,a=26/45))
x11();curve(bias1(x),1,200)
curve(bias2(x),1,200,add=T,col=2)
curve(bias3(x),1,200,add=T,col=3)
x11();curve(bias1(x),1,200,ylim=c(0,1))
curve(bias2(x),1,200,add=T,col=2)
curve(bias3(x),1,200,add=T,col=3)
vara1<-function(n)return(biasa(n,a=4/5))
vara2<-function(n)return(biasa(n,a=8/9))
vara3<-function(n)return(biasa(n,a=4/5))
x11();curve(vara1(x),1,200,ylim=c(0,1))
curve(vara2(x),1,200,add=T,col=2)
curve(vara2(x),1,200,add=T,col=3)
-1/5+1/9
ls()
bias1
bias2
bias3
bias3<-function(n)return(n,a=28/45)
x11();curve(bias1(x),1,200,ylim=c(0,1))
curve(bias2(x),1,200,add=T,col=2)
curve(bias3(x),1,200,add=T,col=3)
bias3<-function(n)return(biasa(n,a=28/45))
curve(bias3(x),1,200,add=T,col=3)
bias3<-function(n)return(biasa(n,a=26/45))
curve(bias3(x),1,200,add=T,col=)
curve(bias3(x),1,200,add=T,col=4)
5/log(5)
1/.102
68,51/7
68.51/7
1.96*0.9
17.64^2
2.5/4
2.5/4+7.5/8+6/7
(2.5/4+7.5/8+6/7)/3
(3/4+7.5/8+6/7)/3
lambda<-2e-5;mu1<-3e-6;mu2<-1e-7
Q<-matrix(c(-lambda,lambda,0,0,-mu1,mu1,mu2,0,-mu2),byrow=T,3,3)
unos<-matrix(1,3,3)
p<-c(1,1,1)%*%(solve(Q+unos))
p
setwd("C:/Users/User/Dropbox/TTT_noRAFA/nuevosresultados")
source('colors_grid.R')
source("tools.R",    encoding="utf-8")
source('test_ttt.R', encoding="utf-8")
K<-1:5
Ns<-c(50,100,500,1000)
param<-expand.grid(K,Ns)
#
# #
for(num in 1:5)
{
tarea<-param[num,1]
N<-param[num,2]
M<-200
fil.res<-paste('Error_TypeI_N_',N,'_tarea_',tarea,'.txt',sep="")
#####################################
ini<-(tarea-1)*M+1;fin<-ini+(M-1)
for(i in ini:fin)
{
ss<-i;set.seed(ss)
myData<-rexp(N)
if(N==50){xgrid=21; hMin=0.1; hMax=1}
if(N==100){xgrid=51; hMin=0; hMax=1}
if(N==500){xgrid=401; hMin=0; hMax=1}
if(N==1000){xgrid=401; hMin=0;hMax=0.9}
res.myData<-test.ttt(myData=myData,xgrid=xgrid,bootstrapSample = 500,hMin=hMin,hMax=hMax)
colors<-summaryColors(res.myData)
typeI.0<-sum(colors[1:2,2])  ##proportion of  not brown (dark gray) pixels in Sizer-0
typeI.2<-sum(colors[9:10,2]) ##proportion of not green (dark gray) pixels in Sizer-2
res<-c(i,typeI.0,typeI.2)
if (i==ini){write(c('i','TypeI_0','TypeI_2'),file=fil.res,append=F,ncol=length(res))}
write(res,file=fil.res,append=T,ncol=length(res))
}
}
K<-1:5;
Ns<-c(50,100,500,1000)
param<-expand.grid(K,Ns)
#
# #
M<-200
error50<-matrix(NA,1,3)
for (num in 1:5)
{
tarea<-param[num,1]
N<-param[num,2]
fil.res<-paste('Error_TypeI_N_',N,'_tarea_',tarea,'.txt',sep="")
res<-as.matrix(read.table(fil.res,h=T),M,3)
error50<-rbind(error50,res)
}
colnames(error50)<-c( "i" ,"SiZer-0","SiZer-2")
error50<-error50[-1,]
summary(error50[,-1])
